/**
 * @file Optimizes gallery images for web performance.
 * Converts HEIC to WebP/JPEG and resizes to max 1920px width.
 */

const sharp = require('sharp');
const fs = require('fs-extra');
const path = require('path');

// Current file: /src/scripts/optimize.js
const root = path.join(__dirname, '..','..');
// Source images folder
const galleryDir = path.join(root, 'content/gallery'); 
// Output build folder
const distGalleryDir = path.join(root, 'dist/assets/gallery');

// TEST_ONLY can be defined during debugging; default to empty to run all
const TEST_ONLY = [];

async function readBuffer(filePath) {
    const buf = await fs.readFile(filePath);
    if (!buf || buf.length === 0) throw new Error('Input Buffer is empty');
    return buf;
}

async function writeOptimized(buffer, destDir, basename) {
    // Ensure the specific album folder exists in dist
    await fs.ensureDir(destDir);
    
    const webpPath = path.join(destDir, `${basename}.webp`);
    const jpgPath = path.join(destDir, `${basename}.jpg`);

    const pipeline = sharp(buffer).rotate().resize({ width: 1920, withoutEnlargement: true });

    // Run both transforms in parallel
    await Promise.all([
        pipeline.clone().webp({ quality: 80 }).toFile(webpPath).catch(err => { throw new Error(`WebP: ${err.message}`); }),
        pipeline.clone().jpeg({ quality: 80, progressive: true }).toFile(jpgPath).catch(err => { throw new Error(`JPEG: ${err.message}`); })
    ]);
}

function filterFilesForTest(album, files) {
    if (!Array.isArray(TEST_ONLY) || TEST_ONLY.length === 0) return files;
    const cfg = TEST_ONLY.find(t => t.album === album);
    return cfg ? files.filter(f => cfg.files.includes(f)) : [];
}

async function optimize() {
    if (!await fs.pathExists(galleryDir)) {
        console.error(`Source directory not found: ${galleryDir}`);
        return;
    }

    const albums = await fs.readdir(galleryDir);

    for (const album of albums) {
        const sourceAlbumPath = path.join(galleryDir, album);
        const distAlbumPath = path.join(distGalleryDir, album);
        
        if (!(await fs.stat(sourceAlbumPath)).isDirectory()) continue;

        const allFiles = await fs.readdir(sourceAlbumPath);
        const files = filterFilesForTest(album, allFiles);

        if (files.length === 0) {
            console.log(`Skipping ${album} (no files to process)`);
            continue;
        }

        console.log(`\nProcessing album: ${album}`);

        for (const file of files) {
            const filePath = path.join(sourceAlbumPath, file);
            const ext = path.extname(file).toLowerCase();
            const basename = path.basename(file, ext);

            // Skip files that aren't source images (like .webp or .jpg that were already generated)
            if (ext === '.webp' || (ext === '.jpg' && allFiles.includes(basename + '.heic'))) continue;

            try {
                let buffer;
                if (['.heic', '.heif'].includes(ext)) {
                    // Prefer an existing JPG generated by a pre-convert step if it exists
                    const jpgCandidate = path.join(sourceAlbumPath, `${basename}.jpg`);
                    if (await fs.pathExists(jpgCandidate)) {
                        buffer = await readBuffer(jpgCandidate);
                    } else {
                        console.warn(`  Skipping ${file} (${ext}) — no converted JPG found`);
                        continue;
                    }
                } else if (['.jpg', '.jpeg', '.png'].includes(ext)) {
                    buffer = await readBuffer(filePath);
                } else {
                    continue; // Skip other file types
                }

                await writeOptimized(buffer, distAlbumPath, basename);
                console.log(`  ✓ Optimized: ${file} (${ext})`);
            } catch (err) {
                console.error(`✗ Failed ${file} (${ext}): ${err.message}`);
            }
        }
    }

    console.log(`\n✓ Done! Check images in ${distGalleryDir}`);
}

optimize();