/**
 * @file Optimizes gallery images for web performance.
 * Converts HEIC to WebP/JPEG and resizes to max 1920px width.
 */

const sharp = require('sharp');
const fs = require('fs-extra');
const path = require('path');

const root = path.join(__dirname, '..');
const galleryDir = path.join(root, 'dist', 'assets', 'gallery');

// TEST_ONLY can be defined during debugging; default to empty to run all
const TEST_ONLY = [];

async function readBuffer(filePath) {
    const buf = await fs.readFile(filePath);
    if (!buf || buf.length === 0) throw new Error('Input Buffer is empty');
    return buf;
}

async function writeOptimized(buffer, destDir, basename) {
    const webpPath = path.join(destDir, `${basename}.webp`);
    const jpgPath = path.join(destDir, `${basename}.jpg`);

    const pipeline = sharp(buffer).rotate().resize({ width: 1920, withoutEnlargement: true });

    // Run both transforms in parallel
    await Promise.all([
        pipeline.clone().webp({ quality: 80 }).toFile(webpPath).catch(err => { throw new Error(`WebP: ${err.message}`); }),
        pipeline.clone().jpeg({ quality: 80, progressive: true }).toFile(jpgPath).catch(err => { throw new Error(`JPEG: ${err.message}`); })
    ]);
}

function filterFilesForTest(album, files) {
    if (!Array.isArray(TEST_ONLY) || TEST_ONLY.length === 0) return files;
    const cfg = TEST_ONLY.find(t => t.album === album);
    return cfg ? files.filter(f => cfg.files.includes(f)) : [];
}

async function optimize() {
    if (!await fs.pathExists(galleryDir)) {
        console.error(`Directory not found: ${galleryDir}`);
        return;
    }

    const albums = await fs.readdir(galleryDir);

    for (const album of albums) {
        const albumPath = path.join(galleryDir, album);
        if (!(await fs.stat(albumPath)).isDirectory()) continue;

        const allFiles = await fs.readdir(albumPath);
        const files = filterFilesForTest(album, allFiles);

        if (files.length === 0) {
            console.log(`Skipping ${album} (no files to process)`);
            continue;
        }

        console.log(`\nProcessing album: ${album}`);

        for (const file of files) {
            const filePath = path.join(albumPath, file);
            const ext = path.extname(file).toLowerCase();
            const basename = path.basename(file, ext);

            try {
                // If it's a HEIC/HEIF, prefer an existing JPG generated by the pre-convert step
                let buffer;
                if (['.heic', '.heif'].includes(ext)) {
                    const jpgCandidate = path.join(albumPath, `${basename}.jpg`);
                    if (await fs.pathExists(jpgCandidate)) {
                        buffer = await readBuffer(jpgCandidate);
                    } else {
                        console.warn(`  Skipping ${file} (${ext}) — no converted JPG found`);
                        continue;
                    }
                } else {
                    buffer = await readBuffer(filePath);
                }

                await writeOptimized(buffer, albumPath, basename);
                console.log(`  ✓ Optimized: ${file} (${ext})`);
            } catch (err) {
                console.error(`✗ Failed ${file} (${ext}): ${err.message}`);
            }
        }
    }

    console.log('\n✓ Done! Check images in dist/assets/gallery/');
}

optimize();
